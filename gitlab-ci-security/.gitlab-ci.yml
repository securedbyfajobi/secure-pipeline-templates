# GitLab CI/CD Security Pipeline Template
# Integrates comprehensive security scanning and compliance checks

stages:
  - build
  - test
  - security-scan
  - security-gate
  - deploy
  - post-deploy-security

variables:
  # Security scanning configurations
  SONAR_PROJECT_KEY: "${CI_PROJECT_NAME}"
  DOCKER_DRIVER: overlay2
  SECURE_LOG_LEVEL: "info"
  FAIL_NEVER: "false"

# Security job templates
include:
  - template: Security/SAST.gitlab-ci.yml
  - template: Security/Secret-Detection.gitlab-ci.yml
  - template: Security/Container-Scanning.gitlab-ci.yml
  - template: Security/Dependency-Scanning.gitlab-ci.yml

# Build stage
build:
  stage: build
  image: docker:20.10.16
  services:
    - docker:20.10.16-dind
  variables:
    DOCKER_TLS_CERTDIR: "/certs"
  before_script:
    - echo $CI_REGISTRY_PASSWORD | docker login -u $CI_REGISTRY_USER --password-stdin $CI_REGISTRY
  script:
    - docker build -t $CI_REGISTRY_IMAGE:$CI_COMMIT_SHA .
    - docker push $CI_REGISTRY_IMAGE:$CI_COMMIT_SHA
  artifacts:
    reports:
      dotenv: build.env
  rules:
    - if: $CI_COMMIT_BRANCH

# Unit and integration tests
test:
  stage: test
  image: python:3.9
  script:
    - pip install -r requirements.txt
    - python -m pytest tests/ --cov=. --cov-report=xml
  artifacts:
    reports:
      coverage_report:
        coverage_format: cobertura
        path: coverage.xml
    paths:
      - coverage.xml
  rules:
    - if: $CI_COMMIT_BRANCH

# SAST Security Scanning
sast:
  stage: security-scan
  variables:
    SAST_EXCLUDED_PATHS: "tests/, docs/, *.md"
  rules:
    - if: $CI_COMMIT_BRANCH

# SonarQube Security Analysis
sonarqube-check:
  stage: security-scan
  image: sonarsource/sonar-scanner-cli:latest
  variables:
    SONAR_USER_HOME: "${CI_PROJECT_DIR}/.sonar"
    GIT_DEPTH: "0"
  cache:
    key: "${CI_JOB_NAME}"
    paths:
      - .sonar/cache
  script:
    - sonar-scanner
      -Dsonar.projectKey=$SONAR_PROJECT_KEY
      -Dsonar.sources=.
      -Dsonar.host.url=$SONAR_HOST_URL
      -Dsonar.login=$SONAR_TOKEN
      -Dsonar.python.coverage.reportPaths=coverage.xml
      -Dsonar.exclusions="**/*_test.py,**/tests/**"
  allow_failure: false
  rules:
    - if: $CI_COMMIT_BRANCH
  dependencies:
    - test

# Snyk Vulnerability Scanning
snyk-security-scan:
  stage: security-scan
  image: snyk/snyk:python-3.9
  script:
    - snyk auth $SNYK_TOKEN
    - snyk test --severity-threshold=high --json > snyk-results.json || true
    - snyk monitor --project-name="$CI_PROJECT_NAME"
  artifacts:
    reports:
      sast: snyk-results.json
    paths:
      - snyk-results.json
    expire_in: 1 week
  rules:
    - if: $CI_COMMIT_BRANCH

# Container Image Security Scanning
container_scanning:
  stage: security-scan
  variables:
    CI_APPLICATION_REPOSITORY: $CI_REGISTRY_IMAGE
    CI_APPLICATION_TAG: $CI_COMMIT_SHA
  rules:
    - if: $CI_COMMIT_BRANCH

# OWASP ZAP Dynamic Security Testing
dast:
  stage: security-scan
  image: owasp/zap2docker-stable:latest
  variables:
    DAST_WEBSITE: "http://test-app:8080"
  script:
    - mkdir -p /zap/wrk/
    - zap-baseline.py -t $DAST_WEBSITE -J zap-report.json -r zap-report.html
  artifacts:
    reports:
      dast: zap-report.json
    paths:
      - zap-report.html
    expire_in: 1 week
  allow_failure: true
  rules:
    - if: $CI_COMMIT_BRANCH == "main"

# Security Gate - Fail pipeline if critical issues found
security-gate:
  stage: security-gate
  image: alpine:latest
  before_script:
    - apk add --no-cache jq curl
  script:
    - |
      # Check SonarQube quality gate
      SONAR_STATUS=$(curl -s -u $SONAR_TOKEN: \
        "$SONAR_HOST_URL/api/qualitygates/project_status?projectKey=$SONAR_PROJECT_KEY" \
        | jq -r '.projectStatus.status')

      if [ "$SONAR_STATUS" != "OK" ]; then
        echo "❌ SonarQube quality gate failed: $SONAR_STATUS"
        exit 1
      fi

      # Check for critical vulnerabilities in Snyk results
      if [ -f "snyk-results.json" ]; then
        CRITICAL_VULNS=$(jq '[.vulnerabilities[] | select(.severity == "critical")] | length' snyk-results.json)
        if [ "$CRITICAL_VULNS" -gt 0 ]; then
          echo "❌ Found $CRITICAL_VULNS critical vulnerabilities"
          exit 1
        fi
      fi

      echo "✅ Security gate passed - no critical issues found"
  dependencies:
    - sonarqube-check
    - snyk-security-scan
  rules:
    - if: $CI_COMMIT_BRANCH

# Deploy to staging
deploy-staging:
  stage: deploy
  image: alpine/helm:latest
  script:
    - helm upgrade --install $CI_PROJECT_NAME ./helm-chart
      --namespace staging
      --set image.tag=$CI_COMMIT_SHA
      --set environment=staging
  environment:
    name: staging
    url: https://staging.$CI_PROJECT_NAME.example.com
  rules:
    - if: $CI_COMMIT_BRANCH == "develop"
  dependencies:
    - security-gate

# Deploy to production
deploy-production:
  stage: deploy
  image: alpine/helm:latest
  script:
    - helm upgrade --install $CI_PROJECT_NAME ./helm-chart
      --namespace production
      --set image.tag=$CI_COMMIT_SHA
      --set environment=production
  environment:
    name: production
    url: https://$CI_PROJECT_NAME.example.com
  rules:
    - if: $CI_COMMIT_BRANCH == "main"
    - when: manual
  dependencies:
    - security-gate

# Post-deployment security verification
post-deploy-security-check:
  stage: post-deploy-security
  image: curlimages/curl:latest
  script:
    - |
      # Wait for deployment to be ready
      sleep 30

      # Basic health check
      if ! curl -f $CI_ENVIRONMENT_URL/health; then
        echo "❌ Health check failed"
        exit 1
      fi

      # Security headers check
      SECURITY_HEADERS=$(curl -s -I $CI_ENVIRONMENT_URL | grep -E "(X-Frame-Options|X-Content-Type-Options|Strict-Transport-Security)")
      if [ -z "$SECURITY_HEADERS" ]; then
        echo "⚠️  Warning: Missing security headers"
      else
        echo "✅ Security headers present"
      fi

      echo "✅ Post-deployment security check passed"
  rules:
    - if: $CI_COMMIT_BRANCH == "main"
  dependencies:
    - deploy-production